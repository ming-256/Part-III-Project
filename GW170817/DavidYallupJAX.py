# -*- coding: utf-8 -*-
"""gw.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/177MzPL08IwbeZhwL7JlnGhgu8wA5Nhod
"""

pip install git+https://git.ligo.org/lscsoft/ligo-segments.git

pip install git+https://github.com/kazewong/jim

pip install git+https://github.com/handley-lab/blackjax@proposal

# pip install --upgrade "jax[cuda12_pip]"==0.4.31 -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html

pip install anesthetic

import blackjax
import blackjax.ns.adaptive
import jax
import jax.numpy as jnp
import numpy as np
import tqdm
from anesthetic import NestedSamples, read_chains
from jimgw.prior import (
    CombinePrior,
    CosinePrior,
    PowerLawPrior,
    SinePrior,
    UniformPrior,
)
from jimgw.single_event.detector import H1, L1
from jimgw.single_event.likelihood import TransientLikelihoodFD, HeterodynedTransientLikelihoodFD
from jimgw.single_event.transforms import (
    MassRatioToSymmetricMassRatioTransform,
)
from jimgw.single_event.waveform import RippleIMRPhenomD

from jimgw.single_event.transforms import (
    SkyFrameToDetectorFrameSkyPositionTransform,
    SphereSpinToCartesianSpinTransform,
    MassRatioToSymmetricMassRatioTransform,
    DistanceToSNRWeightedDistanceTransform,
    GeocentricArrivalTimeToDetectorArrivalTimeTransform,
    GeocentricArrivalPhaseToDetectorArrivalPhaseTransform,
)
from jimgw.transforms import BoundToUnbound


jax.config.update("jax_enable_x64", True)

# | Fetch ligo data
root = "GW150914_IMRPhenomD"
filename = f"{root}.csv"
gps = 1126259462.4
fmin = 20.0
fmax = 1024.0
H1.load_data(gps, 2, 2, fmin, fmax, psd_pad=16, tukey_alpha=0.2)
L1.load_data(gps, 2, 2, fmin, fmax, psd_pad=16, tukey_alpha=0.2)

# | Define the waveform
transforms = [
    MassRatioToSymmetricMassRatioTransform,
]
waveform = RippleIMRPhenomD(f_ref=20)

# | Define the prior
prior = CombinePrior(
    [
        UniformPrior(10.0, 80.0, parameter_names=["M_c"]),
        UniformPrior(0.125, 1.0, parameter_names=["q"]),
        UniformPrior(-1.0, 1.0, parameter_names=["s1_z"]),
        UniformPrior(-1.0, 1.0, parameter_names=["s2_z"]),
        SinePrior(parameter_names=["iota"]),
        PowerLawPrior(1.0, 2000.0, 2.0, parameter_names=["d_L"]),
        # UniformPrior(-0.05, 0.05, parameter_names=["t_c"]),
        UniformPrior(-0.05, 0.05, parameter_names=["t_c"]),
        UniformPrior(0.0, 2 * jnp.pi, parameter_names=["phase_c"]),
        UniformPrior(0.0, jnp.pi, parameter_names=["psi"]),
        UniformPrior(0.0, 2 * jnp.pi, parameter_names=["ra"]),
        CosinePrior(parameter_names=["dec"]),
    ]
)


labels = {
    "M_c": r"$M_c$",
    "q": r"$q$",
    "s1_z": r"$s_{1z}$",
    "s2_z": r"$s_{2z}$",
    "iota": r"$\iota$",
    "d_L": r"$d_L$",
    "t_c": r"$t_c$",
    "phase_c": r"$\phi_c$",
    "psi": r"$\psi$",
    "ra": r"$\alpha$",
    "dec": r"$\delta$",
}

ifos = [H1, L1]

ref_param = {
    "M_c": 3.10497857e01,
    # "eta": 2.46759666e-01,
    "eta": 0.15874815,
    "s1_z": 3.04854781e-01,
    "s2_z": -4.92774588e-01,
    "d_L": 5.47223231e02,
    "t_c": 1.29378808e-02,
    "phase_c": 3.30994042e00,
    "iota": 3.88802965e-01,
    "psi": 3.41074151e-02,
    "ra": 2.55345319e00,
    "dec": -9.52109059e-01,
}


likelihood = HeterodynedTransientLikelihoodFD(
    ifos,
    waveform=waveform,
    # n_bins=301,
    trigger_time=gps,
    duration=4,
    post_trigger_duration=2,
    prior=prior,
    # sample_transforms=sample_transforms,
    likelihood_transforms=transforms,
    ref_params=ref_param,
    popsize=10,
    n_steps=5,
)


vals, ravel = jax.flatten_util.ravel_pytree(
    prior.sample(jax.random.PRNGKey(0), 1)
)


def logprior_fn(x):
    folded_coords = jax.tree_util.tree_map(lambda y: y.squeeze(), ravel(x))

    logprob = prior.log_prob(folded_coords)
    iota_out_of_bounds = (folded_coords["iota"] < 0.0) | (folded_coords["iota"] > jnp.pi)
    logprob = jnp.where(iota_out_of_bounds, -jnp.inf, logprob)
    dec_out_of_bounds = (folded_coords["dec"] < -jnp.pi / 2.0) | (
        folded_coords["dec"] > jnp.pi / 2.0
    )
    logprob = jnp.where(dec_out_of_bounds, -jnp.inf, logprob)
    return logprob


@jax.jit
def ll(x):
    return likelihood.evaluate(
        jax.tree_util.tree_map(
            lambda y: y.squeeze(), transforms[0].forward(ravel(x))
        ),
        None,
    )



# | Define the Nested Sampling algorithm
n_dims = len(prior.parameter_names)
n_live = 1000
n_delete = 500
num_mcmc_steps = n_dims * 3

# | Initialize the Nested Sampling algorithm
nested_sampler = blackjax.ns.adaptive.nss(
    logprior_fn=logprior_fn,
    loglikelihood_fn=ll,
    n_delete=n_delete,
    num_mcmc_steps=num_mcmc_steps,
)


@jax.jit
def one_step(carry, xs):
    state, k = carry
    k, subk = jax.random.split(k, 2)
    state, dead_point = nested_sampler.step(subk, state)
    return (state, k), dead_point


# | Sample live points from the prior
rng_key = jax.random.PRNGKey(0)
rng_key, init_key = jax.random.split(rng_key, 2)
initial_particles = prior.sample(init_key, n_live)
initial_particles = jnp.vstack(jax.tree_util.tree_flatten(initial_particles)[0]).T
state = nested_sampler.init(initial_particles, ll)


# | Run Nested Sampling
dead = []
with tqdm.tqdm(desc="Dead points", unit=" dead points") as pbar:
        while not state.sampler_state.logZ_live - state.sampler_state.logZ < -3:
            (state, rng_key), dead_info = one_step((state, rng_key), None)
            dead.append(dead_info)
            pbar.update(n_delete)  # Update progress bar

# | anesthetic post-processing
dead = jax.tree.map(lambda *args: jnp.concatenate(args), *dead)
live = state.sampler_state
logL = np.concatenate((dead.logL, live.logL), dtype=float)
logL_birth = np.concatenate((dead.logL_birth, live.logL_birth), dtype=float)
data = np.concatenate((dead.particles, live.particles), dtype=float)
columns = ravel(vals).keys()
samples = NestedSamples(
    data, logL=logL, logL_birth=logL_birth, columns=columns, labels=labels
)
samples.to_csv(filename)

logzs = samples.logZ(100)
print(f"{logzs.mean()} +- {logzs.std()}")

# | For post-processing
# samples = read_chains(filename)
params = [
    "M_c",
    "q",
    # "s1_z",
    # "s2_z",
    # "iota",
    # "d_L",
    # "t_c",
    # "phase_c",
    # "psi",
    "ra",
    "dec",
]
samples.plot_2d(params)